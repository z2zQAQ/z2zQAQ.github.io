<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>《局外人》--意义</title>
    <link href="/2023/09/24/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B-%E6%84%8F%E4%B9%89/"/>
    <url>/2023/09/24/%E3%80%8A%E5%B1%80%E5%A4%96%E4%BA%BA%E3%80%8B-%E6%84%8F%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h2 id="面对荒诞的人生，是偶尔体会丧失意义的痛苦还是坚定地体会无意义感"><a href="#面对荒诞的人生，是偶尔体会丧失意义的痛苦还是坚定地体会无意义感" class="headerlink" title="面对荒诞的人生，是偶尔体会丧失意义的痛苦还是坚定地体会无意义感"></a>面对荒诞的人生，是偶尔体会丧失意义的痛苦还是坚定地体会无意义感</h2><p>　莫尔索在面对所有的关系，亲人，友情，爱情，与所有的社会规则，葬礼，婚礼，牢狱，工作，一句“我爱你”，他与所有人保持了绝对的距离，对一切漠不关心，冷漠麻木的同时又对外界绝对的真诚，从不弄虚作假。他坚定地站在了极致的虚无主义视角之下，面对终将孑然一身离开世界的荒诞，莫尔索认为，“我怎么样都可以”，如果我愿意，我可以与你交友，结婚。但是一切的实质都是没有意义的</p><hr><h3 id="意义之网的破碎"><a href="#意义之网的破碎" class="headerlink" title="意义之网的破碎"></a>意义之网的破碎</h3><p>  　我个人对于《局外人》第二段的感受并不深刻，而整个第一段都是在一种介于兴奋与迷茫的状态中看完的，大概是出于感同身受与对于作者可以给出答案的不信任。    </p><p>  　以高考为例，外界会不断地向高中的学生强调“好好学习才能拥有好的未来”。那么，应试教育的“学习”的意义在哪里呢？主流的答案是“考上好的大学”，然后呢？伴随而来的是好工作，好婚姻，好生活，这种模糊的答案或许能在一定程度上作为学习的支撑力，但是一旦受到一次偶然的审视，脆弱的意义之网便即刻破碎，留下的空洞会带来极大地痛苦与虚无感</p><h3 id="自欺式的意义"><a href="#自欺式的意义" class="headerlink" title="自欺式的意义"></a>自欺式的意义</h3><p>  　应试教育的本质–“为了筛选人才”而进行的手段，其最终目的并非“灌输知识”，但是当时的我无法承认消耗自己的大量时间精力的目的是“通过人才筛选”，于是自欺的为学习赋予了诸如“大学生活条件更优越”，“父母可以生活更好”这种相对而言具体却仍然虚无的意义</p><h3 id="重构世界"><a href="#重构世界" class="headerlink" title="重构世界"></a>重构世界</h3><p>  　莫尔索是否对于现代人的意义，就仅仅止步于提醒了人们社会的规则与人的关系本质上都是虚无？我认为他带来的是一种审视：<u><strong>重新审视我们所有的信念，价值，审视社会上所有规则</strong></u>，从而构筑坚定地世界观，莫尔索式的生活方式的前提也是**<u>深刻的认识到了生活的本质</u>**（但是我并未见到他所做出的选择，书中的表述更偏向于一种被动消极的方式）</p><hr><h3 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h3><h4 id="审视意义"><a href="#审视意义" class="headerlink" title="审视意义"></a>审视意义</h4><p>  　莫尔索深刻的认识到了虚无，他接受了虚无，被动的选择了冷漠的生活方式，重新审视“意义”一词，我们甚至可以讨论“意义”的“意义”是什么，“讨论意义”的“意义”是什么，意义一词却只是人类符号学为了交流所创造的一个词汇，我们更应该思考的东西无法直接用文字表述，</p><h4 id="上帝已死"><a href="#上帝已死" class="headerlink" title="上帝已死"></a>上帝已死</h4><p>  　上帝死去的那一刻，人们失去了宗教信仰所带来的强烈的精神力量，意义的定义权重新回到了“个人”身上，这也导致了当代的生活每个人的意义都可以由自己构筑，虽然资本（金钱）似乎取而代之，成为了铭刻在当代人心中的强烈精神支柱，消费主义成为了新的上帝，只是无法否认的是，消费所带来的满足并不如宗教信仰，个人也拥有了更多的机会去思考与构筑自身的意义，同时也导致了强烈的虚无</p><h4 id="何处寻求"><a href="#何处寻求" class="headerlink" title="何处寻求"></a>何处寻求</h4><p>  　正如面对做痛苦的苏格拉底还是快乐的猪的论题，需要获取生活中的大量素材并总结出自己的结论后才能将选择权握在自己手上，在实践与思考中反思世界观，面对生活的意义每个人都可以不尽相同，（包括明确的追求金钱也不失为一种选择）让人从无聊与痛苦的钟摆中拖出</p><h4 id="我"><a href="#我" class="headerlink" title="我"></a>我</h4><p>  　生活的意义被我构筑在<strong>趣味</strong>之上，任何我做出的行为都应该在<strong>不违背个人道德底线，不伤害他人利益</strong>的前提下尽可能的追求有趣（短暂性的欢愉与长期快乐的结合），同时我重视与他人的<strong>关系</strong>，（纵使我一度有严重的唯我论倾向，认为他人也是客体，如今我不可否认他人的主体性），我认为更多人共舞的生活会更加有趣（纵使不是所有人都有这个能力来追求生活的乐趣）</p><hr><br/><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3>]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读笔记</tag>
      
      <tag>think</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java-commons-collections-3.1反序列化漏洞学习</title>
    <link href="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JAVA反序列化分析思路"><a href="#JAVA反序列化分析思路" class="headerlink" title="JAVA反序列化分析思路"></a>JAVA反序列化分析思路</h1><p>从危险函数出发开始寻找不同类的同名函数实现任意方法调用（反射&#x2F;动态加载字节码）</p><h1 id="反射基础"><a href="#反射基础" class="headerlink" title="反射基础"></a>反射基础</h1><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/af6f7ed4fa494b017fd94674d1acac2b.png" alt="截图"></p><p>r是一个Runtime实例，c是一个Runtime类，对c使用反射（getMethod）来获取exec方法，然后在r上调用这个方法</p><h1 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApacheSerialize</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     Transformer[] transformers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Transformer</span>[] &#123;<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstantTransformer</span>(Runtime.class),<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;getMethod&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;String.class, Class[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<span class="hljs-string">&quot;getRuntime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>] &#125;),<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;invoke&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;Object.class, Object[].class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>] &#125;),<br>             <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;String.class &#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;<span class="hljs-string">&quot;calc.exe&quot;</span>&#125;)<br>     &#125;; <span class="hljs-comment">//将transformers数组存入ChaniedTransformer这个继承类</span><br> <span class="hljs-type">Transformer</span> <span class="hljs-variable">transformerChain</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChainedTransformer</span>(transformers);<br><br></code></pre></td></tr></table></figure><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/76c5bf29875d23dd7251f61ea7166a4e.png" alt="截图"> </p><br/><h1 id="漏洞利用分析"><a href="#漏洞利用分析" class="headerlink" title="漏洞利用分析"></a>漏洞利用分析</h1><h2 id="InvokerTransformer（反射利用点）"><a href="#InvokerTransformer（反射利用点）" class="headerlink" title="InvokerTransformer（反射利用点）"></a>InvokerTransformer（反射利用点）</h2><p>首先是由InvokerTransformer类中的transform实现了任意方法调用的同时还在构造函数中导致参数可控<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/0decef64baffec427ca8503b6055d012.png" alt="截图"></p><p>上面的java反射就相当于</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/451006b45403e4916ae89c1bac57168c.png" alt="截图"></p><p>（实际上自己构造的时候在IDE中直接看需要填入的变量还是挺方便的，这里不太好看懂）</p><p>如以下语句就可以实现命令执行</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/797821b047a0aa1970d24586a60e6e61.png" alt="截图"></p><p><strong>将Runtime实例传入transfrom，cls就获取了Runtime类，method获取了Runtime类中的exec方法，然后对Runtime实例使用传入的传输calc</strong></p><p>poc如下<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/286bd714c894d8bf2db07f8f04e02323.png" alt="截图">效果是</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/63a36712d33061393ef3aa3974c6e165.png" alt="截图"> </p><p>最后的目标是回到readObject，所以此时要寻找不同的方法来调用transform（视频原话）</p><hr><h2 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h2><p>在TransformedMap类里面可以找到调用了transfrom方法的位置</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/78ce747963117a1a74432392b4fae2c8.png" alt="截图"></p><p>而valueTransformer是TransformedMap构造函数中的一部分，也就是可控<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/fdb06310411b2b8c0eb1c15a9bd010a4.png" alt="截图"></p><p>如下构造就可以对invokerTransformer调用tansform方法（由于构造函数是保护的，这里用到decorate装饰器）</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/bbcf05b0825c29bc8168c9b99b41ed4f.png" alt="截图"></p><p>继续向上寻找发现是TransformedMap的父类的MapEntry类重写了setValue方法</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/1858e0f761cc2bc3e7092ea2b0a6a5ed.png" alt="截图"></p><p>则可以如下，构造一个TransformedMap并且调用setValue即可（让TransformedMap的value为构造的invokertransformer然后通过setValue调用transform）<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/5cfdd45bdae2b2417775ed46616fd7e6.png" alt="截图"></p><p>现在则需要一个可以遍历数组的地方并且需要value可控或者不同名的调用了setValue</p><hr><h2 id="AnnotationInvocationHandler"><a href="#AnnotationInvocationHandler" class="headerlink" title="AnnotationInvocationHandler"></a>AnnotationInvocationHandler</h2><p>pop链的最后一步<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/3b63106246b1c42b6b3edf765722022d.png" alt="截图"></p><p>满足两个if条件后即可调用setvalue</p><p><strong>但是这个类是一个default类，需要用反射创建，并且可以看见他的构造函数中的第一个参数是一个注解类（如Override）</strong><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/1e001eb8613399c766028cca2208c03f.png" alt="截图"></p><p>此时有三个问题：</p><p><strong>1.如何通过if判断来进入这个setvalue中</strong></p><p><strong>2.setValue貌似不可控</strong></p><p><strong>3.Runtime对象本身是不可序列化的，需要通过反射</strong></p><hr><h2 id="Runtime实现反射调用"><a href="#Runtime实现反射调用" class="headerlink" title="Runtime实现反射调用"></a>Runtime实现反射调用</h2><p><u><strong>解决Runtime不可序列化的问题</strong></u><br>正常情况，由于Runtime对象构造函数是私有的，需要通过getRuntime方法来获取这个对象</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/e50396f2a799915ae1a443566d136c8a.png" alt="截图"></p><p>上图，<u><strong>通过.class获取了Runtime类，然后getMethod反射获取getRuntime方法，然后调用这个方法，获取r这个Runtime实例化对象，最后反射获取exec方法并且在r上调用</strong></u></p><p>转换为InvokerTransform类中则是</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/c98fce6b6222229e8bc9037b6b53c8bb.png" alt="截图"></p><h3 id="chainedtransformer"><a href="#chainedtransformer" class="headerlink" title="chainedtransformer"></a>chainedtransformer</h3><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ff2051707c278f1d4568df83e5ec4438.png" alt="截图"></p><p>这时候通过chainedtransform实现循环调用来使得调用更加简洁</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ade26093c15bbd94bc93ae52b3c6e75e.png" alt="截图"></p><hr><h2 id="进入if语句"><a href="#进入if语句" class="headerlink" title="进入if语句"></a>进入if语句</h2><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/13d3c235cdee3f76a831e4b5adcf462f.png" alt="截图"></p><p>1.通过getKey来获取传入的memberValue中的键是否存在于menberTypes中</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/950f13a925722aa8a01ef421ce1c21bc.png" alt="截图"></p><p>如上，反序列化入口获取了type参数也就是下面的Override.class<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/96228eadb7d6edc8fcf4d351ebcbdd06.png" alt="截图"></p><p>接着获取了这个类中的成员方法，检查poc中传入的键在这个类中的成员方法终会是否存在</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/85b2366957f5b394f8191f99fefe59a2.png" alt="截图"></p><p>则传入一个有成员方法的类并且将key改成他的一个方法名</p><p>如Target的value方法<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/51cc8f6c209cda4b5236f950aae54f76.png" alt="截图"></p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/346ac98b2858372421dd9a0f353b66e2.png" alt="截图">如上修改即可</p><p>2.<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/2814ca791e8398adc40537133b3e1e50.png" alt="截图"></p><p>即检查是否可以强转，这里不需要绕过</p><hr><h2 id="实现可控SetValue"><a href="#实现可控SetValue" class="headerlink" title="实现可控SetValue"></a>实现可控SetValue</h2><p>正常而言，这里会调用</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/60e389a8a285f78d23d2860b183d2f89.png" alt="截图"></p><p>也就是这里的transform的value不可控<img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/8fb0727ffebea79221cd577f1550031b.png" alt="截图"></p><p>也就相当于要把下面的语句换成上面的语句（实现value可控）</p><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/2f8471b5faf8e18282ad8fc0167cc2b1.png" alt="截图"></p><h3 id="ConstantTransformer"><a href="#ConstantTransformer" class="headerlink" title="ConstantTransformer"></a>ConstantTransformer</h3><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/ff2051707c278f1d4568df83e5ec4438.png" alt="截图"></p><p>其transformer方法直接返回自身的一个变量同时可控<br>就可以利用它通过Runtime.getRuntime()创建一个Runtime实例</p><p>此时即可转换成poc中的</p><br/><p><img src="/2023/09/24/java-commons-collections-3-1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/255b549250c082d6699e738adcbddce0.png" alt="截图"></p><hr><h2 id="pop链回溯"><a href="#pop链回溯" class="headerlink" title="pop链回溯"></a>pop链回溯</h2><p>通过反射实例化了AnnotationInvocationHandler类—&gt;对他的value遍历并且调用setvalue，最终来到transform方法(这一步为了实现可控SetValue借助到ConstantTransformer类)—&gt;在value中，我们恶意构造的chainTransformer类实现命令执行</p><br/><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>第一次看java的链子，之前连ctf的java题都没怎么做过，没啥基础，看了点反射跟基本语法就强行看完了，感觉看懂了但是让自己复现还是很困难（语法不清晰），过段时间自己再回来复习一下吧</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码审计</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
